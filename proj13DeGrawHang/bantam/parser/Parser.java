/*
 * Parser.java												2.0 1999/08/11
 *
 * Copyright (C) 1999 D.A. Watt and D.F. Brown
 * Dept. of Computing Science, University of Glasgow, Glasgow G12 8QQ Scotland
 * and School of Computer and Math Sciences, The Robert Gordon University,
 * St. Andrew Street, Aberdeen AB25 1HG, Scotland.
 * All rights reserved.
 *
 * This software is provided free for educational use only. It may
 * not be used for commercial purposes without the prior written permission
 * of the authors.
 *
 *
 * Modified by Haoyu Song for a REVISED LL(1) version of Bantam Java
 * The parser is completely recursive descending
 * 		1)Give precedence to operators
 * 		2)Simplify the AST structures
 * 		3)Support more operations and special symbols
 * 		4)Add more keywords to the beginning of expressions and statements and thus make
 * 		the grammar mostly LL(1)
 *
 * Modified by Dale Skrien to clean up the code
 *
 * In the grammar below, the variables are enclosed in angle brackets and
 * "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * EMPTY indicates a rule with an empty right hand side.
 * All other symbols in the rules are terminals.
 */
/*
 * Edited By: Lucas DeGraw, Jackie Hang, Chris Marcello
 * Project 13
 * Date: March 7, 2019
 */

package proj13DeGrawHang.bantam.parser;

import proj13DeGrawHang.bantam.ast.*;
import proj13DeGrawHang.bantam.lexer.Scanner;
import proj13DeGrawHang.bantam.lexer.Token;
import proj13DeGrawHang.bantam.util.CompilationException;
import proj13DeGrawHang.bantam.util.Error;
import proj13DeGrawHang.bantam.util.ErrorHandler;

import java.awt.desktop.SystemSleepEvent;
import java.io.Reader;
import java.util.List;

import static proj13DeGrawHang.bantam.lexer.Token.Kind.*;


public class Parser
{
    // instance variables
    private Scanner scanner;
    private Token currentToken;
    private ErrorHandler errorHandler;


    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    //----------------------------------
    // checks whether the kind of the current token matches tokenKindExpected.
    // If so, fetches the next token.
    // If not, reports a syntactic bantam.error.

    private void advanceIfMatches(Token.Kind tokenKindExpected) {
        if (currentToken.kind == tokenKindExpected) {
            advance(); // move on to the next token
        }
        else {
            reportSyntacticError(currentToken.position, tokenKindExpected.name(),
                    currentToken.spelling);
        }
    }

    // unconditionally fetch the next token
    private void advance() {
        do {
            currentToken = scanner.scan();
        } while (currentToken.kind == COMMENT);
    }


    //----------------------------------
    //register a SyntaxError and throw a CompilationException to exit from parsing
    private void reportSyntacticError(int position, String expectedToken,
                                      String metToken) {
        String message =
                "At line " + position + ", expected " + expectedToken + ", " + "got" +
                        " " + metToken + " instead.\n ";
        errorHandler.register(Error.Kind.PARSE_ERROR, scanner.getFilename(), position,
                message);
        // exit immediately because the parser can't continue
        throw new CompilationException("Parser error found.");
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {

        //set up scanner
        scanner = new Scanner(filename, errorHandler);

        // start scanning and parsing
        advance();
        return parseProgram();
    }

    // parse the characters in the reader and return the AST
    public Program parse(Reader reader) {

        //set up scanner
        scanner = new Scanner(reader, errorHandler);

        // start scanning and parsing
        advance();
        return parseProgram();
    }


    //------------------------------
    //Begin Parsing

    //<Program> ::= <Class> | <Class> <Program>
    private Program parseProgram() {

        int position = currentToken.position;
        ClassList clist = new ClassList(position,currentToken.colPos);

        while (currentToken.kind != EOF) {
            Class_ aClass = parseClass();
            clist.addElement(aClass);
        }

        return new Program(position,currentToken.colPos, clist);
    }

    //-----------------------------
    //<Class> ::= CLASS <Identifier> <Extension> { <MemberList> }
    //<Extension> ::= EXTENDS <Identifier> | EMPTY
    //<MemberList> ::= EMPTY | <Member> <MemberList>
    private Class_ parseClass() {

        Class_ aClass;
        int position = currentToken.position;


        advanceIfMatches(CLASS);
        Token className = currentToken;
        int colPos = currentToken.colPos;
        advanceIfMatches(IDENTIFIER);
        String parentName = null;
        if (currentToken.kind == EXTENDS) {
            advance();
            parentName = parseIdentifier();
        }
        else {
            parentName = "Object";
        }

        MemberList memberList = new MemberList(currentToken.position,currentToken.colPos);
        advanceIfMatches(LCURLY);
        while (currentToken.kind != RCURLY && currentToken.kind != EOF) {
            Member member = parseMember();
            memberList.addElement(member);
        }
        advanceIfMatches(RCURLY);

        aClass = new Class_(position,colPos, scanner.getFilename(), className.spelling,
                parentName, memberList);
        return aClass;
    }


    //-----------------------------------
    //Fields and Methods

    //<Member> ::= <Field> | <Method>
    //<Method> ::= <Type> <Identifier> ( <Parameters> ) <BlockStmt>>
    //<Field> ::= <Type> <Identifier> <OptInitialValue> ;
    //<OptInitialValue> ::= EMPTY | = <Expression>


    private Member parseMember() {
        Method method;
        String type = parseType();
        int colPos = currentToken.colPos;
        String id = parseIdentifier();
        BlockStmt stmt;
        int position = currentToken.position;

        if (currentToken.kind == LPAREN) // it is a method
        {
            advance();
            FormalList parameters = parseParameters();
            advanceIfMatches(RPAREN);
            stmt = (BlockStmt) parseBlock();
            method = new Method(position,colPos, type, id, parameters, stmt.getStmtList());
            return method;
        }

        else {
            Expr init = null;

            if (currentToken.kind == ASSIGN) {
                advance();
                init = parseExpression();
            }

            advanceIfMatches(SEMICOLON);

            return new Field(position,colPos, type, id, init);
        }

    }


    //-----------------------------------
    //<Stmt>::= <IfStmt> | <BlockStmt> | <DeclStmt> | <ReturnStmt>
    //          <ForStmt> | <WhileStmt> | <BreakStmt> | <ExpressionStmt>
    private Stmt parseStatement() {
        Stmt stmt;

        switch (currentToken.kind) {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }


    //<WhileStmt>::= WHILE ( <Expression> ) <Stmt>
    private Stmt parseWhile() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;

        advance(); // past "while"
        advanceIfMatches(LPAREN);
        Expr expression = parseExpression();
        advanceIfMatches(RPAREN);
        Stmt execution = parseStatement();

        return new WhileStmt(position, colPos,expression, execution);
    }


    //<ReturnStmt>::= RETURN <Expression> ; | RETURN ;
    private Stmt parseReturn() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr expr = null;

        advance(); // accept the RETURN token

        if (currentToken.kind != SEMICOLON) {
            expr = parseExpression();
        }
        advanceIfMatches(SEMICOLON);

        return new ReturnStmt(position,colPos, expr);
    }


    //<BreakStmt>::= BREAK ;
    private Stmt parseBreak() {
        Stmt stmt = new BreakStmt(currentToken.position, currentToken.colPos);
        advance();
        advanceIfMatches(SEMICOLON);
        return stmt;
    }


    //<ExpressionStmt>::= <Expression> ;
    private ExprStmt parseExpressionStmt() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr expr = parseExpression();
        advanceIfMatches(SEMICOLON);
        return new ExprStmt(position,colPos, expr);
    }


    //<DeclStmt>::= VAR <Id> = <Expression>;
    //This makes sure that every local variable is initialized
    private Stmt parseDeclStmt() {

        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Stmt stmt;
        advance(); // the keyword var

        String id = parseIdentifier();
        advanceIfMatches(ASSIGN);
        Expr value = parseExpression();

        stmt = new DeclStmt(position, colPos, id, value);
        advanceIfMatches(SEMICOLON);

        return stmt;
    }


    //<ForStmt>::=FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
    //<Start>::= EMPTY | <Expression>
    //<Terminate>::= EMPTY | <Expression>
    //<Increment>::= EMPTY | <Expression>
    private Stmt parseFor() {

        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;
        Stmt execute;
        advance();

        advanceIfMatches(LPAREN);

        //allow the possibility that start,terminate and increment are null
        if (currentToken.kind != SEMICOLON) {
            start = parseExpression();
        }
        advanceIfMatches(SEMICOLON);

        if (currentToken.kind != SEMICOLON) {
            terminate = parseExpression();
        }
        advanceIfMatches(SEMICOLON);

        if (currentToken.kind != RPAREN) {
            increment = parseExpression();
        }
        advanceIfMatches(RPAREN);

        execute = parseStatement();

        return new ForStmt(position,colPos, start, terminate, increment, execute);
    }


    //<BlockStmt>::=  { <Body> }
    //<Body>::= EMPTY | <Stmt> <Body>
    private Stmt parseBlock() {
        int colPos = currentToken.colPos;
        int position = currentToken.position;
        StmtList stmtList = new StmtList(position,colPos);
        advanceIfMatches(LCURLY);

        while (currentToken.kind != RCURLY) {
            stmtList.addElement(parseStatement());
        }
        advanceIfMatches(RCURLY);

        return new BlockStmt(position, colPos,stmtList);
    }


    //<IfStmt>::= IF (<Expr>) <Stmt> | IF (<Expr>) <Stmt> ELSE <Stmt>
    private Stmt parseIf() {

        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr condition;
        Stmt thenStmt;
        Stmt elseStmt = null;

        advance();
        advanceIfMatches(LPAREN);
        condition = parseExpression();
        advanceIfMatches(RPAREN);
        thenStmt = parseStatement();

        if (currentToken.kind == ELSE) {
            advance();
            elseStmt = parseStatement();
        }

        return new IfStmt(position,colPos, condition, thenStmt, elseStmt);
    }


    //==============================================
    //Expressions
    //Here we introduce the precedence to operations

    //<Expression>::= <LogicalOrExpr> <OptionalAssignment>
    // <OptionalAssignment>::=  = <Expression> | EMPTY
    private Expr parseExpression() {
        Expr result;
        int position = currentToken.position;
        int colPos = currentToken.colPos;

        result = parseOrExpr();
        if (currentToken.kind == ASSIGN && result instanceof VarExpr) {
            advance();
            VarExpr lhs = (VarExpr) result;
            Expr lhsRef = lhs.getRef();
            if(lhsRef != null && (! (lhsRef instanceof VarExpr)
                 || ((VarExpr) lhsRef).getRef() != null))
                reportSyntacticError(position,"a name or a name.name", "expr.name.name");
            Expr right = parseExpression();
            String lhsName = lhs.getName();
            String lhsRefName = (lhs.getRef() == null ? null :
                    ((VarExpr) lhs.getRef()).getName());
            result = new AssignExpr(position,colPos, lhsRefName, lhsName, right);
        }
        else if (currentToken.kind == ASSIGN && result instanceof ArrayExpr) {
            advance();
            ArrayExpr lhs = (ArrayExpr) result;
            Expr lhsRef = lhs.getRef();
            // lhsRef needs to be a VarExpr whose ref is either null or another
            // VarExpr whose ref is null
            if(! (lhsRef instanceof VarExpr)
                    || ((VarExpr) lhsRef).getRef() != null
                    && ((VarExpr) ((VarExpr) lhsRef).getRef()).getRef() != null)
                reportSyntacticError(position,"a name[expr] or a name.name[expr]",
                        "something else");
            Expr right = parseExpression();
            VarExpr lhsExpr = (VarExpr) lhs.getRef();
            String lhsName = lhsExpr.getName();
            String lhsRefName = (lhsExpr.getRef() == null ? null :
                    ((VarExpr) lhsExpr.getRef()).getName());
            Expr index = lhs.getIndex();
            result = new ArrayAssignExpr(position, colPos, lhsRefName, lhsName, index, right);
        }

        return result;
    }


    //<LogicalOR>::= <logicalAND> <LogicalORRest>
    //<LogicalORRest>::= || <LogicalAND> <LogicalORRest> | EMPTY
    private Expr parseOrExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left;

        left = parseAndExpr();
        while (currentToken.spelling.equals("||")) {
            advance();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, colPos,left, right);
        }

        return left;
    }


    //<LogicalAND>::=<ComparisonExpr> <LogicalANDRest>
    //<LogicalANDRest>::= && <ComparisonExpr> <LogicalANDRest> | EMPTY
    private Expr parseAndExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left = parseComparisonExpr();
        while (currentToken.spelling.equals("&&")) {
            advance();
            Expr right = parseComparisonExpr();
            left = new BinaryLogicAndExpr(position,colPos, left, right);
        }

        return left;
    }


    //<ComparisonExpr>::= <RelationalExpr> <EqualOrNotEqual> <RelationalExpr> |
    //                     <RelationalExpr>
    //<EqualOrNotEqual>::=   == | !=
    private Expr parseComparisonExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left = parseRelationalExpr();

        if (currentToken.spelling.equals("==")) {
            advance();
            Expr right = parseRelationalExpr();
            left = new BinaryCompEqExpr(position, colPos,left, right);
        }
        else if (currentToken.spelling.equals("!=")) {
            advance();
            Expr right = parseRelationalExpr();
            left = new BinaryCompNeExpr(position,colPos, left, right);
        }

        return left;
    }


    //<RelationalExpr>::= <AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
    //<ComparisonOp>::= < | > | <= | >= | INSTANCEOF
    private Expr parseRelationalExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left, right;

        left = parseAddExpr();
        switch (currentToken.spelling) {
            case "<":
                advance();
                right = parseAddExpr();
                return new BinaryCompLtExpr(position,colPos, left, right);
            case "<=":
                advance();
                right = parseAddExpr();
                return new BinaryCompLeqExpr(position,colPos, left, right);
            case ">":
                advance();
                right = parseAddExpr();
                return new BinaryCompGtExpr(position, colPos,left, right);
            case ">=":
                advance();
                right = parseAddExpr();
                return new BinaryCompGeqExpr(position, colPos, left, right);
            case "instanceof":
                advance();
                String type = parseType();
                return new InstanceofExpr(position, colPos, left, type);
        }

        return left;
    }


    //<AddExpr>::Ôºù <MultExpr> <MoreMult>
    //<MoreMult>::= + <MultExpr> <MoreMult> | - <MultiExpr> <MoreMult> | EMPTY
    private Expr parseAddExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left = parseMultExpr();

        while (currentToken.kind == PLUSMINUS) {
            if (currentToken.spelling.equals("+")) {
                advance();
                Expr right = parseMultExpr();
                left = new BinaryArithPlusExpr(position, colPos,left, right);
            }
            else {
                advance();
                Expr right = parseMultExpr();
                left = new BinaryArithMinusExpr(position, colPos, left, right);
            }
        }

        return left;
    }


    //<MultiDiv>::= <NewCastOrUnary> <MoreNCU>
    //<MoreNCU>::= * <NewCastOrUnary> <MoreNCU> |
    //             / <NewCastOrUnary> <MoreNCU> |
    //             % <NewCastOrUnary> <MoreNCU> |
    //             EMPTY
    private Expr parseMultExpr() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Expr left, right;


        left = parseNewCastOrUnary();
        while (currentToken.kind == MULDIV) {
            switch (currentToken.spelling) {
                case "/":
                    advance();
                    right = parseNewCastOrUnary();
                    left = new BinaryArithDivideExpr(position, colPos,left, right);
                    break;
                case "*":
                    advance();
                    right = parseNewCastOrUnary();
                    left = new BinaryArithTimesExpr(position,colPos, left, right);
                    break;
                case "%":
                    advance();
                    right = parseNewCastOrUnary();
                    left = new BinaryArithModulusExpr(position,colPos, left, right);
                    break;
            }
        }

        return left;
    }

    //<NewCastOrUnary>::= <NewExpression> | <CastExpression> | <UnaryPrefix>
    private Expr parseNewCastOrUnary() {
        Expr result;

        switch (currentToken.kind) {
            case NEW:
                result = parseNew();
                break;
            case CAST:
                result = parseCast();
                break;
            default:
                result = parseUnaryPrefix();
        }

        return result;
    }


    //<NewExpression>::= NEW <Identifier>() | NEW <Identifier> [ <Expression> ]
    private Expr parseNew() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        advance();

        String type = parseIdentifier();
        if (currentToken.kind == LPAREN) {
            advance();
            advanceIfMatches(RPAREN);
            return new NewExpr(position, colPos, type);
        }
        else {
            advanceIfMatches(LBRACKET);
            Expr sizeExpr = parseExpression();
            advanceIfMatches(RBRACKET);
            return new NewArrayExpr(position, colPos, type, sizeExpr);
        }
    }


    //<CastExpression>::= <Cast> ( <Type> , <Expression> )
    private Expr parseCast() {

        Expr castExpression;
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        advance();

        advanceIfMatches(LPAREN);
        String type = parseType();
        advanceIfMatches(COMMA);
        Expr expression = parseExpression();
        advanceIfMatches(RPAREN);

        castExpression = new CastExpr(position,colPos, type, expression);
        return castExpression;
    }


    //<UnaryPrefix>::= <PrefixOp> <UnaryPreFix> | <UnaryPostfix>
    //<PrefixOp>::= - | ! | ++ | --
    private Expr parseUnaryPrefix() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        Token.Kind kind = currentToken.kind;

        if (currentToken.spelling.equals("-") || kind == UNARYDECR || kind == UNARYINCR || kind == UNARYNOT) {
            advance();
            Expr expr = parseUnaryPrefix();
            if (kind == PLUSMINUS) {
                return new UnaryNegExpr(position,colPos, expr);
            }
            else if (kind == UNARYDECR) {
                return new UnaryDecrExpr(position,colPos, expr, false);
            }
            else if (kind == UNARYINCR) {
                return new UnaryIncrExpr(position,colPos, expr, false);
            }
            else // kind == UNARYNOT
            {
                return new UnaryNotExpr(position,colPos, expr);
            }
        }
        else {
            return parseUnaryPostfix();
        }

    }


    //<UnaryPostfix>::= <Primary> <PostfixOp>
    //<PostfixOp>::= ++ | -- | EMPTY
    private Expr parseUnaryPostfix() {

        Expr unary;
        int position = currentToken.position;
        int colPos = currentToken.colPos;

        unary = parsePrimary();
        if (currentToken.kind == UNARYINCR) {
            unary = new UnaryIncrExpr(position,colPos, unary, true);
            advance();
        }
        else if (currentToken.kind == UNARYDECR) {
            unary = new UnaryDecrExpr(position, colPos, unary, true);
            advance();
        }

        return unary;
    }


    /*
     * <Primary> ::= ( <Expression> ) <ExprSuffix> | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> <IdSuffix> | <Identifier> <Suffix>
     * <IdSuffix>    ::=  . <Identifier> <Suffix> | EMPTY
     * <IndexSuffix> ::=  [ <Expression> ] <IdSuffix> | EMPTY
     * <DispSuffix>  ::=  ( <Arguments> ) <IdSuffix> | EMPTY
     * <ExprSuffix>  ::=  <IdSuffix> | <IndexSuffix>
     * <Suffix>      ::=  <IdSuffix> | <DispSuffix> | <IndexSuffix>
     */


    /*
     * <Primary> ::= ( <Expression> ) <Suffix> | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> <Suffix> | <Identifier> <Suffix>
     * <Suffix> ::=    . <Identifier> <Suffix>
     *               | [ <Expression> ] <Suffix>
     *               | ( <Arguments> ) <Suffix>
     *               | EMPTY
     */

    /*
     * <Primary> ::= ( <Expression> ) <ExprSuffix> | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> <IdSuffix> | <Identifier> <Suffix>
     * <IdSuffix>    ::=  . <Identifier> <Suffix> | EMPTY
     * <IndexSuffix> ::=  [ <Expression> ] <IdSuffix> | EMPTY
     * <DispSuffix>  ::=  ( <Arguments> ) <IdSuffix> | EMPTY
     * <ExprSuffix>  ::=  <IdSuffix> | <IndexSuffix>
     * <Suffix>      ::=  <IdSuffix> | <DispSuffix> | <IndexSuffix>
     */
    private Expr parsePrimary() {
        Expr primary;
        int colPos = currentToken.colPos;
        switch (currentToken.kind) {
            case INTCONST:
                return parseIntConst();
            case BOOLEAN:
                return parseBoolean();
            case STRCONST:
                primary = parseStringConst();
                break;
            case LPAREN:
                advance();
                primary = parseExpression();
                advanceIfMatches(RPAREN);
                if(currentToken.kind == LPAREN) //cannot have ( expr )( args )
                    reportSyntacticError(currentToken.position,
                            "something other than \"(\"",
                            currentToken.kind.name());
                break;
            default:
                String id = parseIdentifier();
                primary = new VarExpr(currentToken.position, currentToken.colPos,null, id);
        }
        // now add the suffixes
        while (    currentToken.kind == DOT
                || currentToken.kind == LPAREN && primary instanceof VarExpr
                || currentToken.kind == LBRACKET) {
            if (currentToken.kind == LPAREN) {
                advance();
                ExprList ar = parseArguments();
                advanceIfMatches(RPAREN);
                VarExpr varExpr = (VarExpr) primary;
                primary = new DispatchExpr(primary.getLineNum(),primary.getColPos(), varExpr.getRef(),
                        varExpr.getName(), ar);
            }
            else if (currentToken.kind == LBRACKET) {
                advance();
                Expr index = parseExpression();
                advanceIfMatches(RBRACKET);
                primary = new ArrayExpr(primary.getLineNum(),primary.getColPos(), primary, null, index);
            }
            else { // currentToken is a DOT
                advance();
                String id = parseIdentifier();
                primary = new VarExpr(currentToken.position,currentToken.colPos, primary, id);
            }
        }

        return primary;
    }


    //<Arguments> ::= EMPTY | <Expression> <MoreArgs>
    //<MoreArgs> ::= EMPTY | , <Expression> <MoreArgs>
    private ExprList parseArguments() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        ExprList ar = new ExprList(position,colPos);

        if (currentToken.kind == RPAREN) {
            return ar;
        }
        else {
            ar.addElement(parseExpression());
            while (currentToken.kind != RPAREN) {
                advanceIfMatches(COMMA);
                ar.addElement(parseExpression());
            }
        }

        return ar;
    }


    //<Parameters> ::=  EMPTY | <Formal> <MoreFormals>
    //<MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
    private FormalList parseParameters() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;

        FormalList parameters = new FormalList(position, colPos);

        if (currentToken.kind == RPAREN) {
            return parameters;
        }
        else {
            parameters.addElement(parseFormal());
            while (currentToken.kind != RPAREN) {
                advanceIfMatches(COMMA);
                parameters.addElement(parseFormal());
            }
        }

        return parameters;
    }


    //<Formal> ::= <Type> <Identifier>
    private Formal parseFormal() {
        return new Formal(currentToken.position, currentToken.colPos, parseType(), parseIdentifier());
    }


    //<Type> ::= <Identifier> <Brackets>
    //<Brackets> ::= [ ] | EMPTY
    private String parseType() {
        String id = parseIdentifier();

        if (currentToken.kind == LBRACKET) {
            advance();
            advanceIfMatches(RBRACKET);
            id += "[]";
        }

        return id;
    }


    //----------------------------------------
    //Terminals


    private String parseOperator() {
        String op = currentToken.getSpelling();
        advance();
        return op;
    }


    private String parseIdentifier() {
        String name = currentToken.getSpelling();
        advanceIfMatches(IDENTIFIER);
        return name;
    }


    private ConstStringExpr parseStringConst() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        String spelling = currentToken.spelling;
        advanceIfMatches(STRCONST);
        return new ConstStringExpr(position,colPos, spelling);
    }


    private ConstIntExpr parseIntConst() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        String spelling = currentToken.spelling;
        advanceIfMatches(INTCONST);
        return new ConstIntExpr(position,colPos, spelling);
    }


    private ConstBooleanExpr parseBoolean() {
        int position = currentToken.position;
        int colPos = currentToken.colPos;
        String spelling = currentToken.spelling;
        advanceIfMatches(BOOLEAN);
        return new ConstBooleanExpr(position,colPos, spelling);
    }


    public static void main(String[] args) {
        ErrorHandler errorHandler = new ErrorHandler();
        Parser parser = new Parser(errorHandler);

        args = new String[]{"testsByDale/AAA.txt"};

        for (String inFile : args) {
            System.out.println("\n========== Results for " + inFile + " =============");
            try {
                errorHandler.clear();
                Program program = parser.parse(inFile);
                System.out.println("  Parsing was successful.");
            } catch (CompilationException ex) {
                System.out.println("  There were errors:");
                List<Error> errors = errorHandler.getErrorList();
                for (Error error : errors) {
                    System.out.println("\t" + error.toString());
                }
            }
        }

    }

}

